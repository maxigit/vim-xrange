Given (a command with input):
  Foo
  bar
  !!! tr 'a-z' 'A-Z' <@in >@out
Execute (the shell command):
  $
  call yrange#ExecuteCommandUnderCursor()
Expect (an output with uppercase):
  Foo
  bar
  !!! tr 'a-z' 'A-Z' <@in >@out
  FOO
  BAR
  !!^out
Given (a command with 2 commands):
  !!! ls <@in
  Foo
  bar
  !!! tr 'a-z' 'A-Z' <@BOF >@out
Execute (the last command):
  $
  call yrange#ExecuteCommandUnderCursor()
Expect (ignore input overlapping with previous command):
  !!! ls <@in
  Foo
  bar
  !!! tr 'a-z' 'A-Z' <@BOF >@out
  !!^out
Given (an awk script with data):
  /a/ {print $0;}
  DATA
  foo
  bar
  hello
  !!!awk -f @in <@data >@out 2>@error
Execute (awk script):
  $
  call yrange#ExecuteCommandUnderCursor()
Expect (no error):
  /a/ {print $0;}
  DATA
  foo
  bar
  hello
  !!!awk -f @in <@data >@out 2>@error
  bar
  !!^out
Given (an awk script with error):
-- filler to shift the awk file line
-- so that we can test the line have been shifted properly
-- when looking at the line number in the error range




  /a/ {
  DATA
  foo
  bar
  hello
  !!!awk -f @in <@data >@out 2>@error
-- Line number wrong
Execute (FIXME: awk script):
  $
  call yrange#ExecuteCommandUnderCursor()
Expect (error with correct filename/lineno):




  /a/ {
  DATA
  foo
  bar
  hello
  !!!awk -f @in <@data >@out 2>@error
  awk: [Vader-workbench]:1: (END OF FILE)
  awk: [Vader-workbench]:1: ^ source files / command line arguments must contain complete functions or rules

  !!^error
  bar
  !!^out
