Given (a command with input):
  Foo
  bar
  !!! tr 'a-z' 'A-Z' <@in >@out
Execute (the shell command):
  $
  call yrange#ExecuteCommandUnderCursor()
Expect (an output with uppercase):
  Foo
  bar
  !!! tr 'a-z' 'A-Z' <@in >@out
  FOO
  BAR
  !!^out
Given (a command with 2 commands):
  !!! ls <@in
  Foo
  bar
  !!! tr 'a-z' 'A-Z' <@BOF >@out
Execute (the last command):
  $
  call yrange#ExecuteCommandUnderCursor()
Expect (ignore input overlapping with previous command):
  !!! ls <@in
  Foo
  bar
  !!! tr 'a-z' 'A-Z' <@BOF >@out
  !!^out
Given (an awk script with data):
  /a/ {print $0;}
  DATA
  foo
  bar
  hello
  !!!awk -f @in <@data >@out 2>@error
Execute (awk script):
  $
  call yrange#ExecuteCommandUnderCursor()
Expect (no error):
  /a/ {print $0;}
  DATA
  foo
  bar
  hello
  !!!awk -f @in <@data >@out 2>@error
  bar
  !!^out
Given (an awk script with error):
-- filler to shift the awk file line
-- so that we can test the line have been shifted properly
-- when looking at the line number in the error range




  /a/ {
  DATA
  foo
  bar
  hello
  !!!efm:awk:\ %f:%l:%m awk -f @in <@data >@out 2>@error
-- ^ The efm is need there. Without it going to the current
-- error open a file in a new buffer
-- Line number wrong
Execute (awk script):
  $
  call yrange#ExecuteCommandUnderCursor()
Expect (error with correct filename, but don't correct filename):




  /a/ {
  DATA
  foo
  bar
  hello
  !!!efm:awk:\ %f:%l:%m awk -f @in <@data >@out 2>@error
  awk: @in:1: (END OF FILE)
  awk: @in:1: ^ source files / command-line arguments must contain complete functions or rules
  !!^error
  !!^out
