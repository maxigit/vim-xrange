Include: common.vader
Before:
  let first = {'valid_name': '[A-Z]'}
  function first.start_regexp_builder(args)
    return printf('^\s*:\(%s\):\(.*\)',a:args.name)
  endfunction
  function first.end_regexp_builder(args)
    return printf('^\s*\.\(%s\)\.\(.*\)',a:args.name)
  endfunction
  let second = extend({'valid_name':'[a-z]'},first, 'keep')
  let third = extend({'valid_name':'[0-9]'},first, 'keep')
  " throw string(third)
  let second.subranger = yrange#ranger#make_from_pattern(third)
  let first.subranger = yrange#ranger#make_from_pattern(second)
  let b:ranger = yrange#ranger#make_from_pattern(first)
  " nested : .. * .. :

  function! MoveTo(range, key)
    call yrange#moveTo(a:range, a:key)
    return a:range
  endfunction

  command! -nargs=1 IsNext :AssertIn {'name':<args>}, yrange#ranger#next_range(b:ranger)->MoveTo('start')
  command! -nargs=1 IsPrevious :AssertIn {'name':<args>}, yrange#ranger#previous_range(b:ranger)->MoveTo('start')



Given (some nested ranges):
  :A:
    :a:
      :1:
        body
      .1.
      :2:
        body 2
      .2.
    .a.
    :b:
      :1:
        body
      .1.
      :2:
        body 2
      .2.
    .b.
  .A.
Execute (find next range):
  IsNext 'a'
  IsNext '1'
  IsNext '2'
  IsNext 'b'
  IsNext '1'
  IsNext '2'
  " wrappinp
  IsNext 'A'
Execute (FIXME find previous range):
  " wrappinp
  IsPrevious '2'
  IsPrevious '1'
  IsPrevious 'b'
  IsPrevious 'a'
  IsPrevious '2'
  IsPrevious '1'
  IsPrevious 'a'
  IsPrevious 'A'
  
