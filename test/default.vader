Include: common.vader
Before:
  let first = {'valid_name': '[A-Z]'}
  function first.start_regexp_builder(args)
    return printf('^\s*:\(%s\):\(.*\)',a:args.name)
  endfunction
  function first.end_regexp_builder(args)
    return printf('^\s*\.\(%s\)\.\(.*\)',a:args.name)
  endfunction
  let second = extend({'valid_name':'[a-z]'},first, 'keep')
  let third = extend({'valid_name':'[0-9]'},first, 'keep')
  " throw string(third)
  let second.subranger = yrange#ranger#make_from_pattern(third)
  let first.subranger = yrange#ranger#make_from_pattern(second)
  let b:ranger = yrange#ranger#make_from_pattern(first)
  let second.subranger.ranger_name = "third"
  let first.subranger.ranger_name = "second"
  " nested : .. * .. :


  command! -nargs=1 IsNext :AssertIn {'name':<args>}, yrange#ranger#next_range(b:ranger)->MoveTo('start')
  command! -nargs=1 IsPrevious :AssertIn {'name':<args>}, yrange#ranger#previous_range(b:ranger)->MoveTo('start')



Given (some nested ranges):
  :A:
    :a:
      :1:
        body
      .1.
      :2:
        body 2
      .2.
    .a.
    :b:
      :1:
        body
      .1.
      :2:
        body 2
      .2.
    .b.
  .A.
Execute (find next range):
  call cursor(6,0)
  "echoe yrange#ranger#current_range(b:ranger)->yrange#range#parent_range().parent
  "echoe yrange#ranger#current_range(b:ranger)->yrange#range#parent_range().ranger->yrange#ranger#parent_range()
  "echoe yrange#ranger#current_range(b:ranger)->yrange#range#parent_range()->yrange#range#parent_range()
  IsNext 'b'
  call cursor(1,0)
Then:
  IsNext 'a'
  IsNext '1'
  IsNext '2'
  IsNext 'b'
  IsNext '1'
  IsNext '2'
  " wrappinp
  IsNext 'A'
