Given (command with old output):
  !!!echo "hello" >@out
  Foo
  !!^out

  NOT TO BE DELETED
Execute (delele output):
  1
  call yrange#CommandUnderCursor()->yrange#execute#DeleteOuterRanges()
Expect:
  !!!echo "hello" >@out

  NOT TO BE DELETED
Execute (echo hello):
  1
  call yrange#CommandUnderCursor()->yrange#execute#ExecuteCommand()
Expect (hello to be present in the range):
  !!!echo "hello" >@out
  hello
  !!^out

  NOT TO BE DELETED
Given (command with 2 old output #2):
  !!!echo "hello" >@out
  Foo
  Bar
  !!^out
  error
  !!^error

  NOT TO BE DELETED
Execute (delele all outputs):
  1
  call yrange#CommandUnderCursor()->yrange#execute#DeleteOuterRanges()
Expect (range to be deleted):
  !!!echo "hello" >@out

  NOT TO BE DELETED
Given (multiline command):
  !!!{echo "hello"
           >@out
  !!}
  Foo
  !!^out
  NOT TO BE DELETED
Execute (delele output):
  call yrange#CommandUnderCursor()->yrange#execute#DeleteOuterRanges()
Expect (range to be deleted):
  !!!{echo "hello"
           >@out
  !!}
  NOT TO BE DELETED
Given (command with no output):
  !!!echo "hello" >@out
Execute (delele output):
  call yrange#CommandUnderCursor()->yrange#execute#DeleteOuterRanges()
Expect (range to be deleted):
  !!!echo "hello" >@out
Given (a commond with two outputs):
  !!! echo "hello" >@out ; echo "ERROR" >@error

Execute (double command):
  call yrange#CommandUnderCursor()->yrange#execute#ExecuteCommand()
Expect (two output ranges in alpha order):
  !!! echo "hello" >@out ; echo "ERROR" >@error
  ERROR
  !!^error
  hello
  !!^out
Then (find outer ranges):
  1
  AssertEqual yrange#CommandUnderCursor()->yrange#search#FindOuterRange('out'), #{rangeStart: 4, rangeEnd: 5}
  AssertEqual yrange#CommandUnderCursor()->yrange#search#FindOuterRange('error'), #{rangeStart: 2, rangeEnd: 3}
Given (buffer with two inputs):
  To be avoided
  
  Content of range 1 (line 3)
  DATA
  Content 
  of range 2         (line 6)
  !!! using @in and @data
Execute (find inner ranges):
  $
  let com = yrange#CommandUnderCursor()
  AssertEqual ['data', 'in'], com->yrange#execute#UsedRangeNames()
  let inner = com->yrange#search#FindInnerRanges(com->yrange#execute#UsedRangeNames())
  " AssertEqual inner, {}
  AssertEqual ['data','in'], inner->keys()
  AssertEqual 2, inner.in.startLine
  AssertEqual 3, inner.in.endLine
  AssertEqual 4, inner.data.startLine
  AssertEqual 6, inner.data.endLine
Given (buffer with one input used (of two)):
  To be avoided
  
  Content of range 1 (line 3)
  DATA
  Content 
  of range 2         (line 6)
  !!! using @in
Execute (ignore unused ranges):
  $
  let com = yrange#CommandUnderCursor()
  AssertEqual ['in'], com->yrange#execute#UsedRangeNames()
  let inner = com->yrange#search#FindInnerRanges(com->yrange#execute#UsedRangeNames())
  " AssertEqual ['in'], inner->keys()
  AssertEqual 2, inner.in.startLine
  AssertEqual 6, inner.in.endLine
--------------------------------------------------
Given (buffer with block at first line):
  hello $name
  !!!name=bob cat @in >@out
Execute (find inner range [1,1]):
  $
  let com = yrange#CommandUnderCursor()
  let inner = com->yrange#search#FindInnerRanges(com->yrange#execute#UsedRangeNames())
  AssertEqual 1, inner.in.startLine
  AssertEqual 1, inner.in.bodyStart
  AssertEqual 1, inner.in.endLine


--------------------------------------------------
Given (buffer with block at second line):

  hello $name
  !!!name=bob cat @in >@out
Execute (find inner range [2,2]):
  $
  let com = yrange#CommandUnderCursor()
  let inner = com->yrange#search#FindInnerRanges(com->yrange#execute#UsedRangeNames())
  AssertEqual 1, inner.in.startLine
  AssertEqual 2, inner.in.bodyStart
  AssertEqual 2, inner.in.endLine

--------------------------------------------------
Given (buffer with block with empty line):
  hello $name

  !!!name=bob cat @in >@out
Execute (find inner range):
  $
  let com = yrange#CommandUnderCursor()
  let inner = com->yrange#search#FindInnerRanges(com->yrange#execute#UsedRangeNames())
  AssertEqual 1, inner.in.startLine
  AssertEqual 1, inner.in.bodyStart
  AssertEqual 2, inner.in.endLine
